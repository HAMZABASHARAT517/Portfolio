<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hamza Basharat - Portfolio</title>

<style>
* { margin:0; padding:0; box-sizing:border-box; }
body, html { height:100%; font-family:'Segoe UI', sans-serif; overflow-x:hidden; background:#000; color:#fff; cursor:default; }

/* Header */
header { 
    position: fixed; top:0; left:0; width:100%; 
    display:flex; justify-content:space-between; align-items:center;
    padding:20px 40px; background: rgba(0,0,0,0.7); 
    z-index:1000; 
}
header .logo { 
    font-size:1.5em; 
    font-weight:bold; 
    color:white;       /* ← updated */ 
}
header nav a { 
    color:white; margin-left:20px; 
    text-decoration:none; padding:6px 12px; 
    border-radius:6px; transition:0.3s; 
}
header nav a:hover { background:#0077b6; }

/* Footer */
footer { 
   position: fixed; bottom:0; left:0; width:100%; 
   display:flex; justify-content:space-between; 
   align-items:center; padding:10px 40px; 
   background: rgba(0,0,0,0.7); color:white; 
   font-size:0.9em; 
}
footer a { margin-left:15px; color:white; text-decoration:none; transition:0.3s; }
footer a:hover { color:#00bcd4; }

/* Main content */
main { position:relative; z-index:1; text-align:center; padding-top:140px; }
h1 { font-size:3em; margin-bottom:10px; }
p { font-size:1.2em; margin-top:20px; }

/* Blinking username */
.blinking {
    font-size: 1.3em;
    color: #00bcd4;
    font-weight: bold;
    animation: blink 1.2s infinite;
    margin-bottom: 10px;
}
@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.2; }
}

/* Rotating roles */
.rotating-container {
    font-size: 1.35em;
    font-weight: 600;
    margin-top: 15px;
}
.rotating-text {
    color: #00bcd4;
    display: inline-block;
    min-width: 240px;
    text-align: center;
    animation: fadeText 0.7s ease-in-out;
}
@keyframes fadeText {
    from { opacity: 0; transform: translateY(6px); }
    to   { opacity: 1; transform: translateY(0); }
}

/* 3D canvas */
#bgCanvas { position:fixed; top:0; left:0; width:100%; height:100%; z-index:0; display:block; }
</style>
</head>
<body>

<!-- Header -->
<header>
  <div class="logo">Hamza Basharat</div>
  <nav>
    <a href="#about">About</a>
    <a href="https://github.com/" target="_blank">GitHub</a>
  </nav>
</header>

<!-- 3D Background -->
<canvas id="bgCanvas"></canvas>

<!-- Main -->
<main>
  <section id="about">

    <div class="blinking">@hamzzza</div>

    <h1>Hello, I'm Hamza Basharat</h1>

    <!-- Rotating roles -->
    <div class="rotating-container">
      <span id="roleText" class="rotating-text">Data Engineer</span> × 
      Data Analyst × 
      Business Intelligence
    </div>

    <p>I build <span style="color:#00bcd4;">data-driven</span> digital experiences that are minimal, functional, and memorable.</p>

  </section>
</main>

<!-- Footer -->
<footer>
  <div>Hamza Basharat / © 2025</div>
  <div>
    <a href="https://linkedin.com/" target="_blank">LinkedIn</a>
    <a href="https://instagram.com/" target="_blank">Instagram</a>
    <a href="https://github.com/" target="_blank">GitHub</a>
  </div>
</footer>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<!-- Rotating Role Script -->
<script>
const roles = [
  "Data Engineer",
  "Data Analyst",
  "Business Intelligence"
];

let index = 0;
const roleText = document.getElementById("roleText");

setInterval(() => {
  index = (index + 1) % roles.length;
  roleText.innerText = roles[index];
  roleText.classList.remove("rotating-text");
  void roleText.offsetWidth;
  roleText.classList.add("rotating-text");
}, 1800);
</script>

<!-- 3D Background Script (Optimized) -->
<script>
/* YOUR OPTIMIZED THREE.JS NETWORK CODE REMAINS EXACTLY AS IS */

/* --- BEGIN (NOT modifying your optimized logic) --- */

const CONFIG = {
  NODE_COUNT: 60,
  MAX_CONNECTIONS: 140,
  NODE_RADIUS: 0.6,
  CONNECTION_PROB: 0.06,
  RAYCAST_MS: 80,
  DEVICE_PIXEL_RATIO_MAX: 1.5,
  BOUNDS: { x: 30, y: 20, z: 30 },
  CENTERING_STRENGTH: 0.02,
  DAMPING: 0.98,
  HOVER_SCALE: 1.6
};

const canvas = document.getElementById('bgCanvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,0,55);

renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, CONFIG.DEVICE_PIXEL_RATIO_MAX));

const ambient = new THREE.AmbientLight(0xffffff, 0.45);
scene.add(ambient);

const pointLight = new THREE.PointLight(0xffffff, 0.9);
pointLight.position.set(40,40,40);
scene.add(pointLight);

const nodeGeo = new THREE.SphereGeometry(CONFIG.NODE_RADIUS, 12, 12);
const nodeMat = new THREE.MeshStandardMaterial({ roughness: 0.4, metalness: 0.5, emissiveIntensity: 0.8, vertexColors: true });

const instanced = new THREE.InstancedMesh(nodeGeo, nodeMat, CONFIG.NODE_COUNT);
instanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

const instanceColors = new Float32Array(CONFIG.NODE_COUNT * 3);
instanced.instanceColor = new THREE.InstancedBufferAttribute(instanceColors, 3);
instanced.instanceColor.setDynamic(true);

scene.add(instanced);

const nodes = [];
for(let i=0;i<CONFIG.NODE_COUNT;i++){
  nodes.push({
    pos: new THREE.Vector3((Math.random()-0.5)*60,(Math.random()-0.5)*40,(Math.random()-0.5)*60),
    vel: new THREE.Vector3((Math.random()-0.5)*0.02,(Math.random()-0.5)*0.02,(Math.random()-0.5)*0.02),
    phase: Math.random()*Math.PI*2,
    baseScale:1
  });

  const c = new THREE.Color().setHSL(Math.random(),0.85,0.55);
  instanceColors[i*3]=c.r; instanceColors[i*3+1]=c.g; instanceColors[i*3+2]=c.b;
}
instanced.instanceColor.needsUpdate=true;

const connections=[];
const maxConn=CONFIG.MAX_CONNECTIONS;

for(let i=0;i<CONFIG.NODE_COUNT;i++){
  for(let j=i+1;j<CONFIG.NODE_COUNT && connections.length<maxConn;j++){
    if(Math.random()<CONFIG.CONNECTION_PROB){ connections.push([i,j]); }
  }
}

const positions=new Float32Array(maxConn*6);
const lineGeom=new THREE.BufferGeometry();
lineGeom.setAttribute("position",new THREE.BufferAttribute(positions,3));
lineGeom.setDrawRange(0,connections.length*2);
const lineMat=new THREE.LineBasicMaterial({color:0x00bcd4,transparent:true,opacity:0.1});
const linesMesh=new THREE.LineSegments(lineGeom,lineMat);
scene.add(linesMesh);

let mouse=new THREE.Vector2(10000,10000);
let hovered=-1;
let lastRay=0;
const raycaster=new THREE.Raycaster();

window.addEventListener("pointermove",(e)=>{
  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
});

window.addEventListener("click",()=>{
  for(let i=0;i<5;i++){
    const id=Math.floor(Math.random()*nodes.length);
    nodes[id].vel.add(new THREE.Vector3((Math.random()-0.5)*0.6,(Math.random()-0.5)*0.6,(Math.random()-0.5)*0.6));
  }
});

function animate(){
  requestAnimationFrame(animate);

  const t=performance.now()*0.0002;
  camera.position.x=45*Math.sin(t);
  camera.position.z=45*Math.cos(t);
  camera.lookAt(0,0,0);

  const tmp=new THREE.Matrix4();
  nodes.forEach((n,i)=>{
    const s=Math.sin(t+n.phase)*0.15;
    n.pos.addScaledVector(n.vel,1);
    n.vel.add(n.pos.clone().multiplyScalar(-CONFIG.CENTERING_STRENGTH));
    n.vel.multiplyScalar(CONFIG.DAMPING);

    tmp.compose(n.pos, new THREE.Quaternion(), new THREE.Vector3(1+s,1+s,1+s));
    instanced.setMatrixAt(i,tmp);
  });
  instanced.instanceMatrix.needsUpdate=true;

  let ptr=0;
  connections.forEach(([a,b])=>{
    const p1=nodes[a].pos, p2=nodes[b].pos;
    positions[ptr++]=p1.x; positions[ptr++]=p1.y; positions[ptr++]=p1.z;
    positions[ptr++]=p2.x; positions[ptr++]=p2.y; positions[ptr++]=p2.z;
  });
  lineGeom.getAttribute("position").needsUpdate=true;
  lineMat.opacity=0.06+0.04*Math.sin(t*40);

  const now=performance.now();
  if(now-lastRay>CONFIG.RAYCAST_MS){
    lastRay=now;
    raycaster.setFromCamera(mouse,camera);
    const hits=raycaster.intersectObject(instanced);
    hovered=hits.length?hits[0].instanceId:-1;
  }

  const hue=(Math.floor(performance.now()*0.008)%360);
  document.body.style.background=`hsl(${hue},28%,5%)`;

  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
/* --- END --- */
</script>

</body>
</html>
