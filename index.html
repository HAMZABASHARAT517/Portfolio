<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hamza Basharat - Portfolio</title>
<link rel="stylesheet" href="css/style.css">
</head>
<body>

<!-- Header -->
<header>
  <div class="logo">Hamza Basharat</div>
  <nav class="top-nav">
    <a href="about.html">About</a>
    <a href="work.html">Work</a>
    <a href="contact.html">Contact</a>
    <a href="https://github.com/HAMZABASHARAT517" target="_blank" class="github-icon">
      GitHub
    </a>
  </nav>
</header>

<!-- 3D Background -->
<canvas id="bgCanvas"></canvas>

<!-- Main Content -->
<main>
  <div class="username-badge">@hamzzza</div>
  <h1>Hello, I'm Hamza Basharat</h1>
  <div class="rotating-box">
    <span id="rotateWord" class="rotating-text">Love</span> × Data Engineer × Data Analyst
  </div>
  <p class="desc-line">
    Engineering fast, scalable data pipelines that power real business decisions.
  </p>
</main>

<!-- Footer -->
<footer>
  <div>Hamza Basharat / © 2025</div>
  <div class="social">
    <a href="https://www.linkedin.com/in/hamza-302yu" target="_blank">LinkedIn</a>
    <a href="https://github.com/HAMZABASHARAT517" target="_blank">GitHub</a>
  </div>
</footer>

<!-- Rotating Words JS -->
<script src="data/rotate.json" type="application/json"></script>
<script>
fetch('data/rotate.json')
.then(res => res.json())
.then(words => {
  let index = 0;
  const rotate = document.getElementById("rotateWord");
  setInterval(() => {
    index = (index + 1) % words.length;
    rotate.innerText = words[index];
    rotate.classList.remove("rotating-text");
    void rotate.offsetWidth;
    rotate.classList.add("rotating-text");
  }, 1800);
});
</script>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script src="script/script.json" type="application/json"></script>
<script>
fetch('script/script.json')
.then(res => res.json())
.then(cfg => {

const canvas = document.getElementById('bgCanvas');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({canvas, alpha:true, antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);

camera.position.z = cfg.cameraZ;

const ambient = new THREE.AmbientLight(0xffffff,0.5);
scene.add(ambient);
const pointLight = new THREE.PointLight(0xffffff,1);
pointLight.position.set(50,50,50);
scene.add(pointLight);

let nodes = [], lines = [];

function createNode(){
  const geometry = new THREE.SphereGeometry(cfg.nodeSize,16,16);
  const material = new THREE.MeshStandardMaterial({
    color: new THREE.Color(`hsl(${Math.random()*360},${cfg.colorSaturation}%,${cfg.colorLightness}%)`),
    emissive: new THREE.Color(`hsl(${Math.random()*360},${cfg.colorSaturation}%,${cfg.emissiveLightness}%)`),
    metalness:0.5, roughness:0.3
  });
  const node = new THREE.Mesh(geometry, material);
  node.position.set((Math.random()-0.5)*cfg.areaX, (Math.random()-0.5)*cfg.areaY, (Math.random()-0.5)*cfg.areaZ);
  scene.add(node);
  nodes.push(node);

  nodes.forEach(other=>{
    if(other!==node && Math.random()<cfg.lineChance){
      const geom = new THREE.BufferGeometry().setFromPoints([node.position, other.position]);
      const mat = new THREE.LineBasicMaterial({color:cfg.lineColor, transparent:true, opacity:0.2});
      const line = new THREE.Line(geom, mat);
      scene.add(line);
      lines.push({line, p1:node, p2:other});
    }
  });
}

for(let i=0;i<cfg.nodeCount;i++) createNode();

const raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2(0,0);
document.addEventListener('mousemove', e=>{
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});

let bgHue = cfg.bgHueStart;

function animate(){
  requestAnimationFrame(animate);

  camera.position.x = cfg.cameraRadius * Math.sin(Date.now()*cfg.cameraSpeed);
  camera.position.z = cfg.cameraRadius * Math.cos(Date.now()*cfg.cameraSpeed);
  camera.lookAt(0,0,0);

  bgHue += cfg.bgHueSpeed;
  document.body.style.background = `hsl(${bgHue}, 30%, 5%)`;

  nodes.forEach(n=>{
    n.rotation.x += cfg.nodeRotateX;
    n.rotation.y += cfg.nodeRotateY;
    n.position.x += (mouse.x)*cfg.mouseEffect*Math.random()*0.1;
    n.position.y += (mouse.y)*cfg.mouseEffect*Math.random()*0.1;
    n.position.z += (Math.random()-0.5)*cfg.nodeJitter;
  });

  lines.forEach(l=>{
    l.line.geometry.setFromPoints([l.p1.position, l.p2.position]);
    l.line.material.opacity = cfg.lineOpacity + cfg.linePulse*Math.sin(Date.now()*cfg.linePulseSpeed);
  });

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(nodes);
  nodes.forEach(n=>n.material.emissiveIntensity = 0.5);
  intersects.forEach(i=>{ i.object.material.emissiveIntensity = 2; });

  renderer.render(scene,camera);
}
animate();

document.addEventListener('click', ()=>{ for(let i=0;i<cfg.clickNodeCount;i++) createNode(); });

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

});
</script>

</body>
</html>
